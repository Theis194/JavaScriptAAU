"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** HTTP request method to indicate the desired action to be performed for a given resource. */
var HttpMethod;
(function (HttpMethod) {
    /** The CONNECT method establishes a tunnel to the server identified by the target resource. */
    HttpMethod["CONNECT"] = "connect";
    /** The DELETE method deletes the specified resource. */
    HttpMethod["DELETE"] = "delete";
    /** The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. */
    HttpMethod["GET"] = "get";
    /** The HEAD method asks for a response identical to that of a GET request, but without the response body. */
    HttpMethod["HEAD"] = "head";
    /** The OPTIONS method is used to describe the communication options for the target resource. */
    HttpMethod["OPTIONS"] = "options";
    /** The PATCH method is used to apply partial modifications to a resource. */
    HttpMethod["PATCH"] = "patch";
    /** The POST method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server. */
    HttpMethod["POST"] = "post";
    /** The PUT method replaces all current representations of the target resource with the request payload. */
    HttpMethod["PUT"] = "put";
    /** The TRACE method performs a message loop-back test along the path to the target resource. */
    HttpMethod["TRACE"] = "trace";
})(HttpMethod = exports.HttpMethod || (exports.HttpMethod = {}));
/** HTTP request protocol. */
var HttpProtocol;
(function (HttpProtocol) {
    /** Unencrypted HTTP protocol. */
    HttpProtocol["HTTP"] = "http";
    /** Encrypted HTTPS protocol. */
    HttpProtocol["HTTPS"] = "https";
})(HttpProtocol = exports.HttpProtocol || (exports.HttpProtocol = {}));
/** HTTP request or response headers. */
class HttpHeaders {
    constructor(headers) {
        if (headers) {
            this.headers = new Map();
            Object.keys(headers).forEach(headerName => {
                let values = headers[headerName];
                if (typeof values === "string") {
                    values = [values];
                }
                if (values.length > 0) {
                    this.headers.set(headerName.toLowerCase(), values);
                }
            });
        }
        else {
            this.headers = new Map();
        }
    }
    /**
     * The first header value for the given header name, if any.
     *
     * @param headerName Header name.
     *
     * @returns The first header value, or null if none.
     * @see #getAll
     */
    get(headerName) {
        const values = this.headers.get(headerName.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    }
    /**
     * All header values for the given header name.
     *
     * @param headerName The header name.
     *
     * @returns an immutable list of header values, or an empty list if none
     * @see #get
     */
    getAll(headerName) {
        return this.headers.get(headerName.toLowerCase()) || new Array();
    }
    toJSON() {
        const result = {};
        this.headers.forEach((value, key) => {
            result[key] =
                value instanceof Array && value.length == 1 ? value[0] : value;
        });
        return result;
    }
}
exports.HttpHeaders = HttpHeaders;
/** HTTP request query parameters. */
class HttpQueryParameters {
    constructor(parameters) {
        if (parameters) {
            this.parameters = new Map();
            Object.keys(parameters).forEach(parameterName => {
                let values = parameters[parameterName];
                if (typeof values === "string") {
                    values = [values];
                }
                if (values.length > 0) {
                    this.parameters.set(parameterName.toLowerCase(), values);
                }
            });
        }
        else {
            this.parameters = new Map();
        }
    }
    /**
     * The first parameter value for the given parameter name, if any.
     *
     * @param parameterName The parameter name.
     *
     * @returns The first parameter value, or null if none.
     * @see #getAll
     */
    get(parameterName) {
        const values = this.parameters.get(parameterName.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    }
    /**
     * All parameter values for the given parameter name.
     *
     * @param parameterName The parameter name.
     *
     * @returns a list of parameter values, or an empty list if none
     * @see #get
     */
    getAll(parameterName) {
        return (this.parameters.get(parameterName.toLowerCase()) || new Array());
    }
    toJSON() {
        const result = {};
        this.parameters.forEach((value, key) => {
            result[key] =
                value instanceof Array && value.length == 1 ? value[0] : value;
        });
        return result;
    }
}
exports.HttpQueryParameters = HttpQueryParameters;
function validateRequest(request) {
    for (const requiredProperty of [
        "method",
        "protocol",
        "host",
        "headers",
        "pathname",
        "query"
    ]) {
        if (!request[requiredProperty]) {
            throw Error(`request.${requiredProperty} is required`);
        }
    }
}
const parseQuery = (searchParams) => {
    const queryMap = new Object();
    for (const [key, value] of searchParams) {
        const parameterName = decodeURIComponent(key);
        const parameterValue = decodeURIComponent(value);
        let existingEntry = queryMap[parameterName];
        if (!existingEntry) {
            existingEntry = new Array();
            queryMap[parameterName] = existingEntry;
        }
        existingEntry.push(parameterValue);
    }
    const query = new HttpQueryParameters(queryMap);
    return query;
};
class HttpRequestBuilder {
    static fromPath(requestData) {
        const url = new URL("file://" + requestData.path);
        const query = parseQuery(url.searchParams);
        const request = {
            timestamp: requestData.timestamp ? requestData.timestamp : undefined,
            method: requestData.method,
            protocol: requestData.protocol,
            host: requestData.host,
            headers: new HttpHeaders(requestData.headers),
            body: requestData.body,
            path: requestData.path,
            pathname: url.pathname,
            query: query
        };
        validateRequest(request);
        return request;
    }
    static fromPathnameAndQuery(requestData) {
        let path = requestData.pathname;
        if (requestData.query) {
            let first = true;
            for (const key in requestData.query) {
                const value = requestData.query[key];
                if (value instanceof String) {
                    if (first) {
                        first = false;
                        path += "?";
                    }
                    else {
                        path += "&";
                    }
                    path +=
                        encodeURIComponent(key) +
                            "=" +
                            encodeURIComponent(value.toString());
                }
                else {
                    for (const entry of value) {
                        if (first) {
                            first = false;
                            path += "?";
                        }
                        else {
                            path += "&";
                        }
                        path += encodeURIComponent(key) + "=" + encodeURIComponent(entry);
                    }
                }
            }
        }
        const query = new HttpQueryParameters(requestData.query);
        const request = {
            timestamp: requestData.timestamp ? requestData.timestamp : undefined,
            method: requestData.method,
            protocol: requestData.protocol,
            host: requestData.host,
            headers: new HttpHeaders(requestData.headers),
            body: requestData.body,
            path: path,
            pathname: requestData.pathname,
            query: query
        };
        validateRequest(request);
        return request;
    }
}
exports.HttpRequestBuilder = HttpRequestBuilder;
class HttpResponseBuilder {
    static from(responseData) {
        let timestamp;
        if (responseData.timestamp instanceof Date) {
            timestamp = responseData.timestamp;
        }
        else if (responseData.timestamp != null) {
            timestamp = Date.parse(responseData.timestamp);
        }
        else {
            timestamp = undefined;
        }
        let statusCode;
        if (typeof responseData.statusCode === "string") {
            statusCode = parseInt(responseData.statusCode);
        }
        else {
            statusCode = responseData.statusCode;
        }
        return {
            timestamp: timestamp,
            statusCode: statusCode,
            headers: new HttpHeaders(responseData.headers),
            body: responseData.body
        };
    }
}
exports.HttpResponseBuilder = HttpResponseBuilder;
class HttpExchangeReader {
    static fromJson(json) {
        const parsedObject = JSON.parse(json);
        const parsedRequest = parsedObject.request;
        const parsedResponse = parsedObject.response;
        const requestTimestamp = parsedRequest.timestamp
            ? new Date(parsedRequest.timestamp)
            : null;
        const protocol = HttpProtocol[parsedRequest.protocol.toUpperCase()];
        const method = HttpMethod[parsedRequest.method.toUpperCase()];
        let request;
        if (parsedRequest.path) {
            request = HttpRequestBuilder.fromPath({
                timestamp: requestTimestamp,
                method: method,
                protocol: protocol,
                host: parsedRequest.host,
                headers: parsedRequest.headers,
                body: parsedRequest.body,
                path: parsedRequest.path
            });
        }
        else if (parsedRequest.pathname) {
            request = HttpRequestBuilder.fromPathnameAndQuery({
                timestamp: requestTimestamp,
                method: method,
                protocol: protocol,
                host: parsedRequest.host,
                headers: parsedRequest.headers,
                body: parsedRequest.body,
                pathname: parsedRequest.pathname,
                query: parsedRequest.query
            });
        }
        else {
            throw new Error("Either 'path' or 'pathname' is required");
        }
        const responseTimestamp = parsedResponse.timestamp
            ? new Date(parsedResponse.timestamp)
            : null;
        const responseHeaders = new HttpHeaders(parsedResponse.headers);
        const response = {
            timestamp: responseTimestamp ? responseTimestamp : undefined,
            statusCode: parsedResponse.statusCode,
            headers: responseHeaders,
            body: parsedResponse.body
        };
        return { request, response };
    }
    static fromJsonLines(jsonLines, callback) {
        jsonLines.split("\n").forEach(line => {
            if (line.length > 0) {
                const exchange = HttpExchangeReader.fromJson(line);
                callback(exchange);
            }
        });
    }
}
exports.HttpExchangeReader = HttpExchangeReader;
class HttpExchangeWriter {
    constructor() {
        this.buffer = "";
    }
    write(exchange) {
        this.buffer += JSON.stringify(exchange) + "\n";
    }
}
exports.HttpExchangeWriter = HttpExchangeWriter;
//# sourceMappingURL=index.js.map